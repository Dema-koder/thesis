\chapter{Introduction}
\label{chap:intro}
\chaptermark{Introduction}

\section{Relevance of the study}
\label{sec:relevance}

Java continues to be one of the main tools for developing enterprise applications and web services. According to the Stack Overflow Developer Survey 2025, this language is consistently in the top 10 in popularity, and the Spring Framework has actually become the de facto standard in enterprise development. At the same time, the requirements for performance and responsiveness of applications are constantly growing, which makes the issues of effective memory management more relevant.

One of the key features of Java is automatic Garbage Collection (GC), which saves programmers from having to manually manage memory. However, this convenience comes at a price: the operation of the garbage collector directly affects the performance of the application. This effect is especially noticeable under high loads and strict requirements for minimum delays \cite{carpen2015performance}.

Research shows \cite{carpen2015performance, pufek2019analysis} that different garbage collectors behave completely differently on multicore systems. For example, Parallel GC, which has long been the default choice in JDK 8, provides high overall throughput, but it can freeze an application for several seconds. On the other hand, the more modern G1 GC (which appeared as the default in JDK 9) tries to keep pauses short and predictable, though sometimes at the cost of reducing overall performance.

In the context of modern architectures - microservices, containerization, cloud platforms - these issues are becoming even more acute.:

\begin{enumerate}
    \item Response time is critical for the user experience. If the service responds for longer than 100-200 milliseconds, users start to notice and get annoyed.
    
    \item Resource efficiency directly affects cloud infrastructure bills. The extra 500 MB of memory for each pod in Kubernetes is real money
    
    \item Predictability is important for SLA performance. If the service suddenly freezes for 3 seconds due to garbage collection, this may violate the service level agreement.
\end{enumerate}

The problem is that most of the existing research on \cite{carpen2015performance, pufek2019analysis, grgic2018comparison} focuses either on synthetic benchmarks like DaCapo suite, or on specific applications like Apache Cassandra. But how garbage collectors behave in regular web applications on Spring Boot --- with their HTTP requests, database connections, caching --- has not been studied enough. Although such applications make up the lion's share of Java development.

\section{Purpose and objectives of the study}
\label{sec:objectives}

\textbf{Purpose of the work} --- to understand how the main Java garbage collectors (Serial GC, Parallel GC, G1 GC, ZGC, Shenandoah GC) work in real web applications, and to develop practical recommendations for their selection and configuration.

To achieve this goal, it is necessary to solve the following \textbf{tasks}:

\begin{enumerate}
    \item To study the existing literature on the mechanisms of operation of various garbage collectors in modern versions of the JDK (from 8th to 21st)
    
    \item Develop a testing methodology that takes into account the specifics of web applications:
    \begin{itemize}
        \item Different types of load (simple CRUD operations, complex queries, traffic spikes)
\item Interaction with databases and external APIs
        \item Web-specific object creation patterns (request-scoped beans, DTOs, etc.)
\end{itemize}
    
    \item Create a typical Spring Boot testing application that includes:
    \begin{itemize}
        \item REST API with different endpoints
        \item Working with the database via JPA/Hibernate
        \item Data caching
        \item Asynchronous processing elements
    \end{itemize}
    
    \item Conduct experiments with each garbage collector, measuring:
    \begin{itemize}
        \item Response time and its distribution (percentages are especially important --- p95, p99, p999)
\item Throughput (how many requests per second are processed)
\item How often GC pauses occur and how long they are
        \item Memory consumption and speed of creation of new objects
        \item CPU load
    \end{itemize}
    
    \item Analyze the received data statistically and understand how the behavior of different GC depends on:
\begin{itemize}
        \item Size of allocated memory (heap)
        \item Type of application load
        \item of JVM Configuration Parameters
    \end{itemize}
    
    \item As a result --- make practical recommendations in the form of an understandable decision tree: <<if you have such and such requirements, take such and such GC with such and such settings>>
\end{enumerate}

\section{Scientific novelty}
\label{sec:novelty}

The scientific novelty of this work consists in several aspects:

\begin{enumerate}
    \item \textbf{Focus on real web applications}. For the first time, a detailed comparison of modern garbage collectors (including the relatively new ZGC and Shenandoah) is carried out on typical Spring Boot applications. This is important because classic benchmarks like DaCapo don't always reflect the reality of web development.
    
    \item \textbf{A comprehensive approach to metrics}. In addition to the standard indicators (duration of pauses, throughput), the work pays special attention to tail latency - the extreme values of delays that are critical for compliance with SLA in production
    
    \item \textbf{Current versions}. The study covers the latest LTS versions of Java (17 and 21) with the latest improvements in garbage collectors. Most of the existing work stops at JDK 8--11, which is already outdated
    
    \item \textbf{Practical orientation}. The results are immediately translated into specific recommendations for real systems, rather than remaining purely academic calculations.
\end{enumerate}

\section{Practical significance}
\label{sec:significance}

The results of this work can be useful to different specialists.:

\begin{enumerate}
    \item \textbf{For developers} --- to understand which choices of the garbage collector and JVM settings affect their applications, and to make informed decisions instead of working with default settings.
    
    \item\textbf{for DevOps engineers and SRE} --- for proper JVM configuration when deployed to Docker/Kubernetes or cloud platforms. Performance problems in production are often associated with suboptimal GC settings.
    
    \item \textbf{Architects} --- when choosing a technology stack and resource planning. Understanding how much memory and CPU an application really needs, taking into account the overhead from the GC, helps to avoid both overpayments for excess resources and problems due to their shortage.
    
    \item \textbf{For educational purposes} --- as structured material with practical examples for studying JVM tuning and best practices of working with Java in production
\end{enumerate}

\section{The structure of the work}
\label{sec:structure}

The work is organized as follows:

\textbf{Chapter~\ref{chap:lr}} --- literature review. It discusses the theoretical foundations of garbage collection, describes the architecture of various GCS in Java, and analyzes existing research on their performance.

\textbf{Chapter~\ref{chap:met}} --- research methodology. It describes how the test application is designed, which load scenarios are used, which metrics are measured, and which tools are used.

\textbf{Chapter~\ref{chap:impl}} --- experimental results. Data on the performance of various GCS under different conditions are presented and analyzed.

\textbf{Chapter~\ref{chap:eval}} --- practical recommendations and discussion. Tips on choosing and configuring garbage collectors are formulated, the limitations of the study and possible directions for further work are discussed.

The \textbf{Conclusion} summarizes the results and formulates the main conclusions.